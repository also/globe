// Generated by CoffeeScript 1.6.3
(function() {
  var CIRCLE_IMAGE, DISTANCE_RATE, MAX_DISTANCE, MAX_ROTATE_Y, MIN_DISTANCE, MIN_ROTATE_Y, MIN_TARGET_DELTA, ORIGIN, POPULATION_COLOR_FUNCTION, ROTATE_RATE, SIZE, Satellite, SimpleCameraController, llToRotationMatrix, llToXyz, shaders, slerp, srand;

  SIZE = 200;

  ROTATE_RATE = 0.005;

  DISTANCE_RATE = 0.015 / 4;

  MIN_DISTANCE = 350;

  MAX_DISTANCE = 1000;

  MAX_ROTATE_Y = Math.PI / 2;

  MIN_ROTATE_Y = -MAX_ROTATE_Y;

  ORIGIN = new THREE.Vector3(0, 0, 0);

  MIN_TARGET_DELTA = 0.005;

  CIRCLE_IMAGE = (function() {
    var canvas, ctx, r, size;
    size = 64;
    r = size / 2;
    canvas = $("<canvas width='" + size + "' height='" + size + "'/>").get(0);
    ctx = canvas.getContext('2d');
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(r, r, r, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();
    return canvas;
  })();

  llToRotationMatrix = function(lng, lat) {
    var m, phi, theta;
    theta = lng * Math.PI / 180;
    phi = (90 - lat) * Math.PI / 180;
    m = new THREE.Matrix4;
    m.rotateY(theta);
    m.rotateZ(phi);
    return m;
  };

  llToXyz = function(lng, lat, size, pos) {
    var phi, theta;
    if (size == null) {
      size = SIZE;
    }
    if (pos == null) {
      pos = new THREE.Vector3;
    }
    theta = (180 - lng) * Math.PI / 180;
    phi = (90 - lat) * Math.PI / 180;
    pos.x = size * Math.sin(phi) * Math.cos(theta);
    pos.y = size * Math.cos(phi);
    pos.z = size * Math.sin(phi) * Math.sin(theta);
    return pos;
  };

  srand = function(radius) {
    var pos, r, t, z;
    if (radius == null) {
      radius = SIZE;
    }
    pos = new THREE.Vector3;
    z = Math.random() * 2 - 1;
    t = Math.random() * Math.PI * 2;
    r = Math.sqrt(1 - z * z) * radius;
    pos.z = radius * z;
    pos.x = r * Math.cos(t);
    pos.y = r * Math.sin(t);
    return pos;
  };

  slerp = function(p0, p1, t) {
    var fn, omega, sinOmega;
    omega = Math.acos(p0.clone().normalize().dot(p1.clone().normalize()));
    sinOmega = Math.sin(omega);
    fn = function(t) {
      var _p0, _p1;
      _p0 = p0.clone();
      _p1 = p1.clone();
      _p0.multiplyScalar(Math.sin((1 - t) * omega) / sinOmega).addSelf(_p1.multiplyScalar(Math.sin(t * omega) / sinOmega));
      return _p0;
    };
    if (t != null) {
      return fn(t);
    } else {
      return fn;
    }
  };

  window.globe = {
    create: function() {
      var animate, camera, cameraController, cameraMoved, cameraPositionNormalized, canvasSizeUniform, createBarChart, createLocation, createParticles, forceUpdate, height, init, initAnimation, nextFrame, onupdate, previousTime, projector, render, renderer, resize, satellite, scene, setCameraController, updateCamera, updatePosition, updated, width;
      camera = null;
      renderer = null;
      scene = null;
      width = height = null;
      onupdate = null;
      cameraPositionNormalized = new THREE.Vector3;
      forceUpdate = false;
      cameraMoved = true;
      previousTime = null;
      projector = new THREE.Projector;
      cameraController = null;
      canvasSizeUniform = {
        type: 'v2',
        value: {
          x: 0,
          y: 0
        }
      };
      satellite = new Satellite;
      init = function(opts) {
        var atmosphereColor, texture, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
        if (opts == null) {
          opts = {};
        }
        width = (_ref = opts.width) != null ? _ref : 800;
        height = (_ref1 = opts.height) != null ? _ref1 : 600;
        onupdate = opts.onupdate;
        renderer = new THREE.WebGLRenderer({
          antialias: true,
          preserveDrawingBuffer: opts.preserveDrawingBuffer
        });
        renderer.setSize(width, height);
        if ((_ref2 = opts.container) != null) {
          _ref2.appendChild(renderer.domElement);
        }
        this.domElement = renderer.domElement;
        renderer.autoClear = false;
        renderer.setClearColorHex((_ref3 = opts.backgroundColor) != null ? _ref3 : 0x000000, (_ref4 = opts.backgroundOpacity) != null ? _ref4 : 1);
        camera = new THREE.PerspectiveCamera(30, width / height, 1, 10000);
        setCameraController(new SimpleCameraController(this));
        cameraController.satellite = satellite;
        canvasSizeUniform.value.x = width;
        canvasSizeUniform.value.y = height;
        scene = new THREE.Scene;
        if ((_ref5 = opts.atmosphere) != null ? _ref5 : true) {
          atmosphereColor = (_ref6 = opts.atmosphereColor) != null ? _ref6 : 0xffffff;
          scene.add(globe.createAtmosphere({
            atmosphereColor: atmosphereColor
          }));
        } else {
          atmosphereColor = 0;
        }
        if ((_ref7 = opts.globe) != null ? _ref7 : true) {
          texture = opts.globeTexture instanceof THREE.Texture ? (opts.globeTexture, window.setTimeout(function() {
            return typeof opts.onload === "function" ? opts.onload() : void 0;
          }, 1)) : THREE.ImageUtils.loadTexture((_ref8 = opts.globeTexture) != null ? _ref8 : 'world.jpg', null, opts.onload);
          scene.add(globe.createEarth({
            texture: texture,
            atmosphereColor: atmosphereColor
          }));
        }
        if (opts.stars) {
          scene.add(globe.createStars());
        }
        scene.add(camera);
        return renderer.clear();
      };
      resize = function(w, h) {
        var event;
        width = w;
        height = h;
        renderer.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        event = new CustomEvent('resize', {
          detail: {
            width: width,
            height: height
          },
          bubbles: false
        });
        return renderer.domElement.dispatchEvent(event);
      };
      initAnimation = function() {
        previousTime = +(new Date);
        return nextFrame();
      };
      setCameraController = function(controller) {
        return cameraController = controller;
      };
      updateCamera = function(position, target, up) {
        camera.position.copy(position);
        if (up != null) {
          camera.up.copy(up);
        }
        camera.lookAt(target != null ? target : scene.position);
        cameraPositionNormalized.copy(camera.position).normalize();
        return cameraMoved = true;
      };
      updatePosition = function(time) {
        var deltaT;
        deltaT = time - previousTime;
        cameraController.update(deltaT);
        if (forceUpdate || cameraMoved) {
          forceUpdate = false;
          cameraMoved = false;
          if (typeof onupdate === "function") {
            onupdate();
          }
        }
        return previousTime = time;
      };
      render = function(time) {
        updatePosition(time);
        renderer.clear();
        return renderer.render(scene, camera);
      };
      nextFrame = function() {
        return window.requestAnimationFrame(animate, renderer.domElement);
      };
      animate = function(t) {
        render(t);
        return nextFrame();
      };
      createLocation = function(lng, lat) {
        var pos, posNormalized, projectedPos;
        pos = llToXyz(lng, lat);
        projectedPos = pos.clone();
        posNormalized = pos.clone().normalize();
        return {
          angle: function() {
            return Math.acos(posNormalized.dot(cameraPositionNormalized));
          },
          screenPosition: function() {
            var screen;
            projectedPos.copy(pos);
            screen = projector.projectVector(projectedPos, camera);
            return {
              x: width * (screen.x + 1) / 2,
              y: height * (-screen.y + 1) / 2
            };
          }
        };
      };
      updated = function() {
        return forceUpdate = true;
      };
      createParticles = function(opts) {
        var add, attributes, defaultTexture, fragmentShader, fragmentShaderTextureSelection, fragmentShaderTextures, geometry, i, image, material, name, num, particles, position, scale, shader, texture, textureInfo, textures, uniformName, uniforms, vertexShader, _ref, _ref1, _ref2, _ref3;
        textures = (_ref = opts.textures) != null ? _ref : {
          "default": (_ref1 = opts.texture) != null ? _ref1 : CIRCLE_IMAGE
        };
        fragmentShaderTextures = "";
        fragmentShaderTextureSelection = [];
        textureInfo = {
          none: {
            num: -1,
            scale: 0
          }
        };
        uniforms = {};
        num = 0;
        for (name in textures) {
          image = textures[name];
          uniformName = "texture_" + num;
          texture = new THREE.Texture(image);
          texture.needsUpdate = true;
          texture.minFilter = THREE.LinearFilter;
          if (image.width === image.height) {
            scale = new THREE.Vector2(1, 1);
          } else if (image.width < image.height) {
            scale = new THREE.Vector2(image.height / image.width, 1);
          } else {
            scale = new THREE.Vector2(1, image.width / image.height);
          }
          uniforms[uniformName] = {
            type: 't',
            value: num,
            texture: texture
          };
          fragmentShaderTextures += "uniform sampler2D " + uniformName + ";\n";
          fragmentShaderTextureSelection.push("if (f_textureNum == " + num + ".0) {color = texture2D(" + uniformName + ", position);}");
          textureInfo[name] = {
            num: num,
            scale: scale
          };
          num += 1;
        }
        defaultTexture = (_ref2 = textureInfo["default"]) != null ? _ref2 : textureInfo.none;
        attributes = {
          size: {
            type: 'f',
            value: []
          },
          particleColor: {
            type: 'c',
            value: []
          },
          particleOpacity: {
            type: 'f',
            value: []
          },
          textureNum: {
            type: 'f',
            value: []
          },
          textureScale: {
            type: 'v2',
            value: []
          }
        };
        shader = shaders.particle;
        vertexShader = shader.vertexShader;
        if ((_ref3 = opts.sizeAttenuation) != null ? _ref3 : true) {
          vertexShader = '#define USE_SIZEATTENUATION\n' + vertexShader;
          uniforms.canvasSize = THREE.UniformsUtils.clone({
            canvasSize: canvasSizeUniform
          }).canvasSize;
          renderer.domElement.addEventListener('resize', function(_arg) {
            var height, width, _ref4;
            _ref4 = _arg.detail, width = _ref4.width, height = _ref4.height;
            uniforms.canvasSize.value.x = width;
            uniforms.canvasSize.value.y = height;
            return uniforms.canvasSize.needsUpdate = true;
          });
        }
        fragmentShader = fragmentShaderTextures + shader.fragmentShader.replace('// TEXTURE SELECTION', fragmentShaderTextureSelection.join('\n else\n '));
        material = new THREE.ShaderMaterial({
          transparent: true,
          vertexShader: vertexShader,
          fragmentShader: fragmentShader,
          attributes: attributes,
          uniforms: uniforms
        });
        geometry = new THREE.Geometry;
        particles = (function() {
          var _i, _ref4, _results;
          _results = [];
          for (i = _i = 0, _ref4 = opts.particleCount; 0 <= _ref4 ? _i < _ref4 : _i > _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
            position = new THREE.Vector3;
            _results.push((function(position, i) {
              var altitude, destination, normalizedPosition, origin, p, setTexture, slerpP, updateSlerp;
              normalizedPosition = new THREE.Vector3;
              altitude = 0;
              origin = destination = null;
              slerpP = null;
              setTexture = function(t) {
                attributes.textureNum.value[i] = t.num;
                attributes.textureNum.needsUpdate = true;
                attributes.textureScale.value[i] = t.scale;
                return attributes.textureScale.needsUpdate;
              };
              p = {
                position: position,
                altitude: 0,
                reset: function() {
                  var _ref5, _ref6, _ref7;
                  this.setPosition(0, 0);
                  this.setSize((_ref5 = opts.size) != null ? _ref5 : 1);
                  this.setColor(new THREE.Color((_ref6 = opts.color) != null ? _ref6 : 0xffffff));
                  this.setOpacity((_ref7 = opts.opacity) != null ? _ref7 : 1);
                  return setTexture(defaultTexture);
                },
                setPosition: function(lng, lat) {
                  normalizedPosition.copy(llToXyz(lng, lat, 1));
                  return this.setAltitude(altitude);
                },
                setSize: function(size) {
                  attributes.size.value[i] = size;
                  return attributes.size.needsUpdate = true;
                },
                setColor: function(color) {
                  attributes.particleColor.value[i] = color;
                  return attributes.particleColor.needsUpdate = true;
                },
                setOpacity: function(opacity) {
                  attributes.particleOpacity.value[i] = opacity;
                  return attributes.particleOpacity.needsUpdate = true;
                },
                setOrigin: function(lng, lat) {
                  origin = llToXyz(lng, lat, 1);
                  return updateSlerp();
                },
                setDestination: function(lng, lat) {
                  destination = llToXyz(lng, lat, 1);
                  return updateSlerp();
                },
                setPositionMix: function(t) {
                  normalizedPosition = slerpP(t);
                  return this.setAltitude(altitude);
                },
                setAltitude: function(altitude) {
                  position.copy(normalizedPosition).multiplyScalar(SIZE * (1 + altitude));
                  return geometry.verticesNeedUpdate = true;
                },
                setTexture: function(name) {
                  var t;
                  t = textureInfo[name];
                  return setTexture(t);
                }
              };
              updateSlerp = function() {
                if ((origin != null) && (destination != null)) {
                  slerpP = slerp(origin, destination);
                  return p.distance = Math.acos(origin.clone().dot(destination)) / Math.PI;
                }
              };
              p.reset();
              geometry.vertices.push(position);
              return p;
            })(position, i));
          }
          return _results;
        })();
        add = function() {
          var ps;
          ps = new THREE.ParticleSystem(geometry, material);
          ps.sortParticles = true;
          return scene.add(ps);
        };
        return {
          add: add,
          particles: particles
        };
      };
      createBarChart = function(opts) {
        var add, attributes, createBar, defaultPointColor, defaultPointGeometry, geometry, mix, points, setSizeTargetMix, setSizeTargets, setSizes, uniforms;
        if (opts == null) {
          opts = {};
        }
        points = [];
        defaultPointColor = new THREE.Color;
        if (opts.defaultDimension == null) {
          opts.defaultDimension = 0.75;
        }
        defaultPointGeometry = new THREE.CubeGeometry(opts.defaultDimension, opts.defaultDimension, 1);
        defaultPointGeometry.vertices.forEach(function(v) {
          return v.z += 0.5;
        });
        if (opts.colorFunction == null) {
          opts.colorFunction = POPULATION_COLOR_FUNCTION;
        }
        geometry = new THREE.Geometry;
        geometry.dynamic = true;
        uniforms = {};
        attributes = {
          size: {
            type: 'f',
            value: []
          },
          customPosition: {
            type: 'v3',
            value: []
          }
        };
        if (opts.customColor) {
          attributes.customColor = {
            type: 'c',
            value: []
          };
        }
        if (opts.sizeTarget) {
          attributes.sizeTarget = {
            type: 'f',
            value: []
          };
          uniforms.sizeTargetMix = {
            type: 'f',
            value: 0
          };
        }
        createBar = function(lng, lat, pointGeometry) {
          var mix, p, pos, set, setColor, setSize, setSizeTarget, vertexCount, vertexOffset;
          if (pointGeometry == null) {
            pointGeometry = defaultPointGeometry;
          }
          vertexOffset = geometry.vertices.length;
          vertexCount = pointGeometry.vertices.length;
          THREE.GeometryUtils.merge(geometry, pointGeometry);
          pos = llToXyz(lng, lat);
          set = function(name, value) {
            var attribute, i, _i, _ref;
            attribute = attributes[name];
            for (i = _i = vertexOffset, _ref = vertexOffset + vertexCount; vertexOffset <= _ref ? _i < _ref : _i > _ref; i = vertexOffset <= _ref ? ++_i : --_i) {
              attribute.value[i] = value;
            }
            return attribute.needsUpdate = true;
          };
          set('customPosition', pos);
          setSize = function(size) {
            this.size = size;
            return set('size', this.size);
          };
          setSizeTarget = function(sizeTarget) {
            this.sizeTarget = sizeTarget;
            return set('sizeTarget', this.sizeTarget);
          };
          mix = function(sizeTargetMix) {
            return this.setSize(this.size + (this.sizeTarget - this.size) * sizeTargetMix);
          };
          setColor = function(color) {
            return set('color', color);
          };
          p = {
            setSize: setSize,
            setSizeTarget: setSizeTarget,
            mix: mix,
            setColor: setColor
          };
          p.setSize(0);
          if (opts.sizeTarget) {
            p.setSizeTarget(0);
          }
          if (opts.customColor) {
            p.setColor(defaultPointColor);
          }
          points.push(p);
          return p;
        };
        setSizes = function(sizes, m) {
          var i, s, _i, _len, _results;
          if (m == null) {
            m = 1;
          }
          _results = [];
          for (i = _i = 0, _len = sizes.length; _i < _len; i = ++_i) {
            s = sizes[i];
            _results.push(points[i].setSize(s * m));
          }
          return _results;
        };
        setSizeTargets = function(sizeTargets, m) {
          var i, t, _i, _len, _results;
          if (m == null) {
            m = 1;
          }
          _results = [];
          for (i = _i = 0, _len = sizeTargets.length; _i < _len; i = ++_i) {
            t = sizeTargets[i];
            _results.push(points[i].setSizeTarget(t * m));
          }
          return _results;
        };
        setSizeTargetMix = function(sizeTargetMix) {
          this.sizeTargetMix = sizeTargetMix;
          return uniforms.sizeTargetMix.value = sizeTargetMix;
        };
        mix = function(sizeTargetMix) {
          var p, _i, _len, _ref;
          if (sizeTargetMix == null) {
            sizeTargetMix = (_ref = this.sizeTargetMix) != null ? _ref : 0;
          }
          for (_i = 0, _len = points.length; _i < _len; _i++) {
            p = points[_i];
            p.mix(sizeTargetMix);
          }
          return this.setSizeTargetMix(0);
        };
        add = function() {
          var mesh, vertexShader;
          vertexShader = opts.colorFunction + shaders.point.vertexShader;
          if (opts.customColor) {
            vertexShader = "#define USE_CUSTOM_COLOR;\n" + vertexShader;
          }
          if (opts.sizeTarget) {
            vertexShader = "#define USE_SIZE_TARGET;\n" + vertexShader;
          }
          mesh = new THREE.Mesh(geometry, new THREE.ShaderMaterial({
            uniforms: uniforms,
            attributes: attributes,
            vertexShader: vertexShader,
            fragmentShader: shaders.point.fragmentShader
          }));
          mesh.frustumCulled = false;
          return scene.add(mesh);
        };
        return {
          points: points,
          createBar: createBar,
          add: add,
          setSizes: setSizes,
          setSizeTargets: setSizeTargets,
          setSizeTargetMix: setSizeTargetMix,
          mix: mix
        };
      };
      return {
        init: init,
        initAnimation: initAnimation,
        resize: resize,
        render: render,
        createBarChart: createBarChart,
        createParticles: createParticles,
        updated: updated,
        createLocation: createLocation,
        satellite: satellite,
        setCameraController: setCameraController,
        updateCamera: updateCamera
      };
    },
    createEarth: function(opts) {
      var geometry, material, mesh, shader, uniforms;
      shader = shaders.earth;
      uniforms = THREE.UniformsUtils.clone(shader.uniforms);
      uniforms.atmosphereColor.value = new THREE.Color(opts.atmosphereColor);
      uniforms.texture.texture = opts.texture;
      material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      });
      geometry = new THREE.SphereGeometry(SIZE, 100, 50);
      mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.y = Math.PI;
      mesh.updateMatrix();
      mesh.matrixAutoUpdate = false;
      return mesh;
    },
    createAtmosphere: function(opts) {
      var geometry, material, mesh, shader, uniforms;
      shader = shaders.atmosphere;
      uniforms = THREE.UniformsUtils.clone(shader.uniforms);
      uniforms.color.value = new THREE.Color(opts.atmosphereColor);
      material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      });
      geometry = new THREE.SphereGeometry(SIZE, 100, 50);
      mesh = new THREE.Mesh(geometry, material);
      mesh.scale.set(1.4, 1.4, 1.4);
      mesh.flipSided = true;
      mesh.matrixAutoUpdate = false;
      mesh.updateMatrix();
      return mesh;
    },
    createStars: function() {
      var geometry, i, material, ps, texture, v, _i;
      geometry = new THREE.Geometry;
      for (i = _i = 1; _i <= 800; i = ++_i) {
        v = srand(SIZE * 10 + Math.random() * SIZE * 5);
        geometry.vertices.push(v);
      }
      texture = new THREE.Texture(CIRCLE_IMAGE);
      texture.needsUpdate = true;
      material = new THREE.ParticleBasicMaterial({
        size: 12,
        map: texture,
        blending: THREE.AdditiveBlending,
        transparent: true
      });
      material.color.setHSV(.65, .0, .5);
      ps = new THREE.ParticleSystem(geometry, material);
      ps.updateMatrix();
      return ps;
    },
    circle: CIRCLE_IMAGE,
    llToXyz: llToXyz,
    slerp: slerp,
    observeMouse: function(camera, target, _arg) {
      var $domElement, distanceRange, eventTypes, events, mouseDown, mousemove, mouseup, position, targetDown, type, _ref;
      _ref = _arg != null ? _arg : {}, type = _ref.type, distanceRange = _ref.distanceRange;
      eventTypes = {
        mouse: {
          start: 'mousedown',
          move: 'mousemove',
          end: 'mouseup mouseleave'
        },
        touch: {
          start: 'touchstart',
          move: 'touchmove',
          end: 'touchend'
        }
      };
      if (type == null) {
        type = 'mouse';
      }
      if (distanceRange == null) {
        distanceRange = [1.5, 10];
      }
      events = eventTypes[type];
      mouseDown = null;
      targetDown = null;
      position = function(e) {
        if (e.originalEvent.touches != null) {
          e = e.originalEvent.touches[0];
        }
        return {
          x: -e.clientX,
          y: e.clientY
        };
      };
      $domElement = $(target);
      $domElement.bind('mousewheel', function(e) {
        var newDistance;
        newDistance = camera.distanceTarget - e.originalEvent.wheelDeltaY * 0.005;
        camera.setDistanceTarget(Math.min(Math.max(distanceRange[0], newDistance), distanceRange[1]));
        return e.preventDefault();
      });
      mouseup = function(e) {
        $domElement.unbind(events.move, mousemove).unbind(events.end, mouseup);
        return $domElement.css('cursor', '');
      };
      mousemove = function(e) {
        var mouse, scale, zoomDamp;
        mouse = position(e);
        zoomDamp = (camera.distance * SIZE) / 1000;
        if ((e.originalEvent.touches == null) || e.originalEvent.touches.length === 1) {
          camera.setPositionTarget({
            lng: targetDown.lng + (mouse.x - mouseDown.x) * .25 * zoomDamp,
            lat: Math.max(-90, Math.min(89, targetDown.lat + (mouse.y - mouseDown.y) * .25 * zoomDamp))
          });
        }
        scale = e.originalEvent.scale;
        if (scale != null) {
          return camera.setDistanceTarget(Math.min(10, Math.max(1.3, camera.distanceTarget + ((scale - 1) / -10))));
        }
      };
      return $domElement.bind(events.start, function(e) {
        e.preventDefault();
        $domElement.bind(events.move, mousemove);
        $domElement.bind(events.end, mouseup);
        mouseDown = position(e);
        targetDown = {
          lng: camera.positionTarget.lng,
          lat: camera.positionTarget.lat
        };
        return $domElement.css('cursor', 'move');
      });
    },
    Satellite: Satellite = (function() {
      function Satellite() {
        this.updated = true;
        this.moving = false;
        this.position = {
          lng: 0,
          lat: 0
        };
        this.positionTarget = {
          lng: 0,
          lat: 0
        };
        this.distance = 5;
        this.distanceTarget = 5;
      }

      Satellite.prototype.setPosition = function(_arg) {
        var lat, lng;
        lng = _arg.lng, lat = _arg.lat;
        if (lng == null) {
          lng = this.position.lng;
        }
        if (lat == null) {
          lat = this.position.lat;
        }
        this.position = {
          lng: lng,
          lat: lat
        };
        this.positionTarget = {
          lng: lng,
          lat: lat
        };
        return this.updated = true;
      };

      Satellite.prototype.setPositionTarget = function(_arg) {
        var lat, lng;
        lng = _arg.lng, lat = _arg.lat;
        if (lng == null) {
          lng = this.positionTarget.lng;
        }
        if (lat == null) {
          lat = this.positionTarget.lat;
        }
        this.positionTarget = {
          lng: lng,
          lat: lat
        };
        return this.moving = true;
      };

      Satellite.prototype.movePositionTarget = function(_arg) {
        var lat, lng;
        lng = _arg.lng, lat = _arg.lat;
        lng = this.positionTarget.lng + (lng != null ? lng : 0);
        lat = this.positionTarget.lat + (lat != null ? lat : 0);
        return this.setPositionTarget({
          lng: lng,
          lat: lat
        });
      };

      Satellite.prototype.setAltitude = function(altitude) {
        return this.setDistance(altitude + 1);
      };

      Satellite.prototype.setDistance = function(distance) {
        this.distance = distance;
        this.distanceTarget = this.distance;
        return this.updated = true;
      };

      Satellite.prototype.setAltitudeTarget = function(altitudeTarget) {
        return this.setDistanceTarget(altitudeTarget + 1);
      };

      Satellite.prototype.setDistanceTarget = function(distanceTarget) {
        this.distanceTarget = distanceTarget;
        return this.moving = true;
      };

      Satellite.prototype.update = function(deltaT) {
        var moved, orbitingUpdated, result, rotateDistance;
        if (this.moving) {
          moved = false;
          rotateDistance = Math.min(1, ROTATE_RATE * deltaT);
          if (Math.abs(this.positionTarget.lng - this.position.lng) < MIN_TARGET_DELTA) {
            this.position.lng = this.positionTarget.lng;
          } else {
            moved = true;
            this.position.lng += (this.positionTarget.lng - this.position.lng) * rotateDistance;
          }
          if (Math.abs(this.positionTarget.lat - this.position.lat) < MIN_TARGET_DELTA) {
            this.position.lat = this.positionTarget.lat;
          } else {
            moved = true;
            this.position.lat += (this.positionTarget.lat - this.position.lat) * rotateDistance;
          }
          if (Math.abs(this.distanceTarget - this.distance) < MIN_TARGET_DELTA) {
            this.distance = this.distanceTarget;
          } else {
            moved = true;
            this.distance += (this.distanceTarget - this.distance) * Math.min(1, DISTANCE_RATE * deltaT);
          }
          this.moving = moved;
        }
        result = this.moving || this.updated;
        this.updated = false;
        if (this.orbiting) {
          orbitingUpdated = this.orbiting.update(deltaT);
          result || (result = orbitingUpdated);
          if (result) {
            this.matrix = llToRotationMatrix(this.orbiting.position.lng, this.orbiting.position.lat);
          }
        }
        return result;
      };

      Satellite.prototype.toCartesian = function(target) {
        var orbitingPosition;
        if (this.orbiting) {
          llToXyz(this.position.lng, this.position.lat, SIZE * this.distance, target);
          this.matrix.multiplyVector3(target);
          orbitingPosition = this.orbiting.toCartesian(new THREE.Vector3);
          return target.addSelf(orbitingPosition);
        } else {
          return llToXyz(this.position.lng, this.position.lat, SIZE * this.distance, target);
        }
      };

      return Satellite;

    })(),
    SimpleCameraController: SimpleCameraController = (function() {
      function SimpleCameraController(context) {
        this.context = context;
        this.positionCartesian = new THREE.Vector3;
        this.up = new THREE.Vector3(0, 1, 0);
      }

      SimpleCameraController.prototype.update = function(deltaT) {
        if (this.satellite.update(deltaT)) {
          this.satellite.toCartesian(this.positionCartesian);
          return this.context.updateCamera(this.positionCartesian, this.target, this.up);
        }
      };

      return SimpleCameraController;

    })()
  };

  shaders = {
    earth: {
      uniforms: {
        texture: {
          type: 't',
          value: 0,
          texture: null
        },
        atmosphereColor: {
          type: 'c'
        }
      },
      vertexShader: "varying vec3 vNormal;\nvarying vec2 vUv;\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  vNormal = normalize(normalMatrix * normal);\n  vUv = uv;\n}",
      fragmentShader: "uniform sampler2D texture;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nuniform vec3 atmosphereColor;\nvoid main() {\n  vec3 diffuse = texture2D(texture, vUv).xyz;\n  float intensity = 1.05 - dot(vNormal, vec3(0.0, 0.0, 1.0));\n  vec3 atmosphere = atmosphereColor * pow(intensity, 3.0);\n  gl_FragColor = vec4(diffuse + atmosphere, 1.0);\n}"
    },
    atmosphere: {
      uniforms: {
        color: {
          type: 'c'
        }
      },
      vertexShader: "varying vec3 vNormal;\nvoid main() {\n  vNormal = normalize(normalMatrix * normal);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
      fragmentShader: "varying vec3 vNormal;\nuniform vec3 color;\nvoid main() {\n  float intensity = pow(0.5 - dot(vNormal, vec3(0, 0, 1.0)), 4.0);\n  gl_FragColor = vec4(color, 0.6) * intensity;\n}"
    },
    point: {
      vertexShader: "varying vec4 f_color;\nattribute float size;\nattribute vec3 customPosition;\n\n#ifdef USE_SIZE_TARGET\n  attribute float sizeTarget;\n  uniform float sizeTargetMix;\n#endif\n\n#ifdef USE_CUSTOM_COLOR\n  attribute vec3 customColor;\n#endif\n\nvoid main() {\n  float mixedSize = size;\n  #ifdef USE_SIZE_TARGET\n    mixedSize = mix(size, sizeTarget, sizeTargetMix);\n  #endif\n  // look at the origin\n  vec3 lz = normalize(-customPosition);\n  if (length(lz) == 0.0) {\n    lz.z = 1.0;\n  }\n  vec3 lup = vec3(0,1,0);\n  vec3 lx = normalize(cross(lup, lz));\n  if (length(lx) == 0.0) {\n    lz.x = lx.x + 0.0001;\n    lx = normalize(cross(lup, lz));\n  }\n  vec3 ly = normalize(cross(lz, lx));\n\n  lz *= -mixedSize * " + (SIZE.toFixed(1)) + ";\n  mat4 customMat = mat4(lx, 0,\n                   ly, 0,\n                   lz, 0,\n                   customPosition,1);\n  gl_Position =  projectionMatrix  *\n                modelViewMatrix *\n                customMat *\n                vec4(position.x, position.y, position.z,1);\n\n  #ifdef USE_CUSTOM_COLOR\n    f_color = vec4(customColor, 1.0);\n  #endif\n  #ifndef USE_CUSTOM_COLOR\n    f_color = color(mixedSize);\n  #endif\n}",
      fragmentShader: "varying vec4 f_color;\nvoid main() {\n  gl_FragColor = f_color;\n}"
    },
    particle: {
      vertexShader: "attribute float size;\nuniform vec2 canvasSize;\nattribute vec3 particleColor;\nattribute float particleOpacity;\nattribute float textureNum;\nattribute vec2 textureScale;\nvarying vec4 f_color;\nvarying float f_textureNum;\nvarying vec2 f_textureScale;\n\nvoid main() {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  gl_Position = projectionMatrix * mvPosition;\n  #ifdef USE_SIZEATTENUATION\n    gl_PointSize = size * (canvasSize.y / length(mvPosition.xyz));\n  #else\n    gl_PointSize = size;\n  #endif\n  f_color = vec4(particleColor, particleOpacity);\n  f_textureNum = textureNum;\n  f_textureScale = textureScale;\n}",
      fragmentShader: "varying vec4 f_color;\nvarying float f_textureNum;\nvarying vec2 f_textureScale;\n\nvoid main() {\n  vec4 color;\n  if (f_textureNum < 0.0) {\n    gl_FragColor = f_color;\n  }\n  else {\n    vec2 position = vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y) * f_textureScale;\n    if (position.x >= 0.0 && position.x <= 1.0 && position.y >= 0.0 && position.y <= 1.0) {\n      // TEXTURE SELECTION\n      gl_FragColor = f_color * color;\n    }\n    else {\n      gl_FragColor = vec4(0,0,0,0);\n    }\n  }\n}"
    }
  };

  POPULATION_COLOR_FUNCTION = '// found, randomly, at https://www.h3dapi.org:8090/MedX3D/trunk/MedX3D/src/shaders/StyleFunctions.glsl\nvec3 HSVtoRGB(float h, float s, float v) {\n  if (s == 0.0) return vec3(v);\n\n  h /= 60.0;\n  int i = int(floor(h));\n  float f = h - float(i);\n  float p = v * (1.0 - s);\n  float q = v * (1.0 - s * f);\n  float t = v * (1.0 - s * (1.0 - f));\n\n  if (i == 0) return vec3(v,t,p);\n  if (i == 1) return vec3(q,v,p);\n  if (i == 2) return vec3(p,v,t);\n  if (i == 3) return vec3(p,q,v);\n  if (i == 4) return vec3(t,p,v);\n              return vec3(v,p,q);\n}\n\nvec4 color(float size) {\n  return vec4(HSVtoRGB((0.6 - size * 0.5) * 360.0, 1.0, 1.0), 1.0);\n}';

}).call(this);
